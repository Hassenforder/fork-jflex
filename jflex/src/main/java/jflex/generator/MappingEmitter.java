package jflex.generator;

import java.io.File;
import java.io.PrintWriter;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import jflex.base.Build;
import jflex.core.AbstractLexScan;
import jflex.core.LexParse;
import jflex.core.NFA;
import jflex.core.RegExp;
import jflex.core.RegExps;
import jflex.dfa.DFA;
import jflex.io.FileUtils;
import jflex.option.Options;

/**
 * This class print the mapping between regexp and ETerminal Basically this class is useless for a
 * standard scanner but for lsp compliant scanner it can can be used to suggest a text based on a
 * token
 *
 * @author Michel Hassenforder
 */
public final class MappingEmitter {

  private final File inputFile;
  final String outputFileName;

  private final PrintWriter out;
  private final AbstractLexScan scanner;
  private final LexParse parser;
  private final DFA dfa;
  private final NFA nfa;

  private boolean[] isTransition;

  /**
   * Emits the java code.
   *
   * @param inputFile input grammar.
   * @param parser a {@link LexParse}.
   * @param dfa a {@link DFA}.
   * @param nfa a {@link NFA}.
   * @param writer output file.
   */
  MappingEmitter(
      String outputFileName,
      File inputFile,
      LexParse parser,
      DFA dfa,
      NFA nfa,
      PrintWriter writer) {
    this.outputFileName = outputFileName;
    this.out = writer;
    this.parser = parser;
    this.scanner = parser.scanner;
    this.inputFile = inputFile;
    this.dfa = dfa;
    this.nfa = nfa;
  }

  private void println() {
    out.println();
  }

  private void println(String line) {
    out.println(line);
  }

  private void print(String line) {
    out.print(line);
  }

  public static String sourceFileString(File file) {
    String path = FileUtils.getRelativePath(Options.getRootDirectory(), file);
    if (File.separatorChar == '\\') {
      path = FileUtils.slashify(path);
    }
    // Character '\' can be use for Unicode representation, e.g. \\u000A is new line
    return path.replace("\\", "\\\\");
  }

  private void emitHeader() {
    println("// DO NOT EDIT");
    println("// Generated by JFlex " + Build.VERSION + " http://jflex.de/");
    println("// source: " + sourceFileString(inputFile));
    println("");
    if (scanner.packageName() != null || !scanner.packageName().isEmpty()) {
      println("package " + scanner.packageName() + ";");
    }
  }

  private void emitImports() {
    println("import java.util.EnumMap;");
    println("import java.util.Map;");
    println("import java.util.Set;");
    println("import java.util.TreeSet;");
  }

  private void emitClassName() {
    println("public class Mappings {");
  }

  private void emitMembers() {
    println("	static private Map<ETerminal, Set<String>> mappings = null;");
  }

  private void emitCtor() {
    println("	private Mappings () {");
    println("	}");
  }

  private void emitAddMapping() {
    println("	private static void addMapping (ETerminal terminal, String text) {");
    println("		Set<String>	set;");
    println("		if (! mappings.contains(terminal)) {");
    println("			set = new TreeSet<String>();");
    println("			mappings.put(terminal, set);");
    println("		} else {");
    println("			set = mappings.get(terminal);");
    println("		}");
    println("		set.add (text);");
    println("	}");
  }

  private Pattern returnPattern = Pattern.compile(".*return symbol\\((ETerminal\\.[^,]*),.*");

  private Pattern textPattern = Pattern.compile("(.|\n|\r)*content :[ \\n\\r]*(.*)");

  private void emitFillMappings() {
    println("	private static void fillMappings() {");
    RegExps regExps = nfa.getRegExps();
    for (int i = 0; i < regExps.getNum(); i++) {
      RegExp regExp = regExps.getRegExp(i);
      Matcher returnMatcher = returnPattern.matcher(regExps.getAction(i).content);
      if (!returnMatcher.find()) continue;
      String terminal = returnMatcher.group(1);
      String text = "";
      if ("STRING".equals(regExp.typeName())) {
        Matcher textMatcher = textPattern.matcher(regExp.toString());
        if (textMatcher.find()) {
          text = textMatcher.group(2).trim();
        }
      }
      println("      addMapping(" + terminal + ", \"" + text + "\");");
    }
    println("	}");
  }

  private void emitGetMappings() {
    println("	private static Map<ETerminal, Set<String>> getMappings () {");
    println("		if (mappings == null) {");
    println("			mappings = new EnumMap<>(ETerminal.class);");
    println("			fillMappings ();");
    println("		}");
    println("		return mappings;");
    println("	}");
  }

  private void emitPublics() {
    println("	public static String getTextFor (ETerminal symbol) {");
    println("		return getMappings().get(symbol);");
    println("	}");
  }

  /** Main Emitter method. */
  public void emit() {

    emitHeader();
    println();

    emitImports();
    println();

    emitClassName();
    println();

    emitMembers();
    println();

    emitCtor();
    println();

    emitAddMapping();
    println();

    emitFillMappings();
    println();

    emitGetMappings();
    println();

    emitPublics();
    println();
    println("}");
    out.close();
  }
}
